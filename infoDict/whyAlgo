link: https://developer.algorand.org/docs/get-started/basics/why_algorand/

The native currency¶

Each blockchain has its own native currency that plays a critical role in incentivizing good network behavior. Algorand’s native currency is called the Algo.

If you hold Algos, you can register to participate in consensus, which means that you will participate in the process of proposing and voting on new blocks.

The Algo also acts as a utility token. When you’re building an application, you need algos to pay transaction fees and to serve as minimum balance deposits if you want to store data on the blockchain. The cost of these fees and minimum balances is very low, fractions of a penny in most cases.
Fees¶

Fees are calculated based on the size of the transaction and a user can choose to augment a fee to help prioritize acceptance into a block when network traffic is high and blocks are consistently full. There is no concept of gas fees on Algorand.

The minimum fee for a transaction is only 1,000 microAlgos or 0.001 Algos.
Openness¶

Earlier, we compared a blockchain ledger that is distributed, to a traditional ledger that is owned by a single entity. Technically, a blockchain ledger could be owned and operated by just a few entities, but this wouldn’t be a very good blockchain since such a centralized set of nodes could easily manipulate the state of the blockchain.

Algorand is completely open and permissionless. Anyone, anywhere in the world, who owns Algos can participate in consensus.
Decentralization¶

Similarly, if all the people who are running nodes are the same company or set of companies then we find ourselves in a similar situation where we aren’t much better off than just having a central database controlled by a select few.

On Algorand, since the protocol is open and permissionless, nodes can and do exist all over the world.

    See the Algorand Metrics Dashboard for a view on node decentralization.

Transparency¶

How do you know that anything that we are telling you here is true? You can check for yourself. All of the code for the core protocol is open source. Anyone can review it and contribute to it.

    The Algorand source code

Forking (or lack of)¶

Forking is when a blockchain diverges into two separate paths. Sometimes this forking is intentional, like when a significant part of the community wants to change the fundamentals of the protocol. Other times this forking is accidental and occurs when two miners find a block at almost the same time. Eventually, one of the paths will be abandoned, which means that all transactions that occurred since that fork on the abandoned path (the orphaned chain) will be invalid. This has important implications for transaction finality, which we’ll talk about in a bit.

Since Algorand is pure proof-of-stake and uses a voting mechanism to validate blocks, forking is impossible. In a worst case scenario, if the committee is taking longer to reach agreement, the blockchain will slow down or temporarily stall.
Performance¶

The speed at which blocks are produced, the amount of transactions that can fit into a block, and when those transactions are considered final are important factors to consider when choosing a blockchain. For Algorand, performance is and will always be a key focus area for the core development team.
Throughput¶

You want to choose a blockchain that can scale and handle high throughput so that your users don’t experience long wait times when interacting with your application.

On Algorand, blocks are produced every 3.9 seconds and can hold up to 25,000 transactions, which results in a throughput of about 6,000 transactions per second (6000 TPS).
Finality¶

In proof-of-work blockchains, since forking is a possibility, transactions can’t be considered final until a certain amount of time passes and the likelihood of the transaction being on an orphaned chain is practically zero. This means that the actual throughput of this type of blockchain is caveated by a delay in finality. Downstream processes in an application must take this into account to avoid compounding issues if a transaction ends up being invalid.

As we mentioned earlier, Algorand does not have forking so transactions are final as soon as they are confirmed in a block. A throughput of 6,000 TPS then actually means 6,000 finalized transactions per second.
Core features¶

Algorand makes it easy to tokenize, transfer, and program conditions on any instrument of value. Create fungible tokens, NFTs, and security tokens with a single transaction (no smart contract code required). Or program sophisticated decentralized applications (dApps) with Algorand smart contracts.
Developer tools¶

Developers can write smart contracts in Python or Reach (a Javascript-like language) and can use one of four SDKs (Python, JavaScript, Golang, Java) to connect to on-chain assets or applications.

Algorand has a growing ecosystem of developer tools like IDEs, tools for monitoring, etc.

    Explore developer tools from the community

The team & ecosystem¶

The Algorand protocol is completely open source, so why can’t anyone just go create a copy and create another Algorand-like blockchain? Well they absolutely can, but then they’ll have to convince everyone why the new one is better. As we’ve seen, the technology is a critical component to a blockchain, but so is the ecosystem built around it.

Algorand has some of the best researchers and developers in the world actively developing and improving Algorand’s core protocol. The Algorand Foundation invests heavily in strategy around governance and growth of the ecosystem to promote long-term value for all algo holders. This part is not easy to replicate.
Governance¶

The Algorand Foundation, a non-profit organization that launched the Algorand MainNet, governs the Algorand network and is committed to continuing to decentralize it and put more decision-making into the hands of the Algorand community at large.

    Visit the Algorand Foundation website for more information.
